/**
 * Command handler for slash commands
 * Handles deterministic operations without AI
 */
import { readFile, writeFile, readdir, access, rm } from 'fs/promises';
import { join, basename, resolve, relative } from 'path';
import { Conversation, CommandResult } from '../types';
import * as db from '../db/conversations';
import * as codebaseDb from '../db/codebases';
import * as sessionDb from '../db/sessions';
import * as templateDb from '../db/command-templates';
import { isPathWithinWorkspace } from '../utils/path-validation';
import { listWorktrees, execFileAsync } from '../utils/git';
import { getIsolationProvider } from '../isolation';
import * as isolationEnvDb from '../db/isolation-environments';
import {
  cleanupMergedWorktrees,
  cleanupStaleWorktrees,
  getWorktreeStatusBreakdown,
  MAX_WORKTREES_PER_CODEBASE,
} from '../services/cleanup-service';
import { getLughWorkspacesPath, getCommandFolderSearchPaths } from '../utils/lugh-paths';
import { toggleVerbose, setVerbose, isVerboseEnabled } from '../utils/logger';
import { signalAbort } from '../orchestrator/abort-manager';

/**
 * Convert an absolute path to a relative path from the repository root
 * Falls back to showing relative to workspace if not in a git repo
 */
function shortenPath(absolutePath: string, repoRoot?: string): string {
  // If we have a repo root, show path relative to it
  if (repoRoot) {
    const relPath = relative(repoRoot, absolutePath);
    // Only use relative path if it doesn't start with '..' (i.e., it's within the repo)
    if (!relPath.startsWith('..')) {
      return relPath;
    }
  }

  // Fallback: show relative to workspace
  const workspacePath = getLughWorkspacesPath();
  const relPath = relative(workspacePath, absolutePath);
  if (!relPath.startsWith('..')) {
    return relPath;
  }

  // If all else fails, return the original path
  return absolutePath;
}

/**
 * Recursively find all .md files in a directory and its subdirectories
 */
async function findMarkdownFilesRecursive(
  rootPath: string,
  relativePath = ''
): Promise<{ commandName: string; relativePath: string }[]> {
  const results: { commandName: string; relativePath: string }[] = [];
  const fullPath = join(rootPath, relativePath);

  const entries = await readdir(fullPath, { withFileTypes: true });

  for (const entry of entries) {
    // Skip hidden directories and common exclusions
    if (entry.name.startsWith('.') || entry.name === 'node_modules') {
      continue;
    }

    if (entry.isDirectory()) {
      // Recurse into subdirectory
      const subResults = await findMarkdownFilesRecursive(rootPath, join(relativePath, entry.name));
      results.push(...subResults);
    } else if (entry.isFile() && entry.name.endsWith('.md')) {
      // Found a markdown file - use filename as command name
      results.push({
        commandName: basename(entry.name, '.md'),
        relativePath: join(relativePath, entry.name),
      });
    }
  }

  return results;
}

export function parseCommand(text: string): { command: string; args: string[] } {
  // Match quoted strings or non-whitespace sequences
  const matches = text.match(/"[^"]+"|'[^']+'|\S+/g) ?? [];

  if (matches.length === 0 || !matches[0]) {
    return { command: '', args: [] };
  }

  const command = matches[0].substring(1); // Remove leading '/'
  const args = matches.slice(1).map(arg => {
    // Remove surrounding quotes if present
    if ((arg.startsWith('"') && arg.endsWith('"')) || (arg.startsWith("'") && arg.endsWith("'"))) {
      return arg.slice(1, -1);
    }
    return arg;
  });

  return { command, args };
}

export async function handleCommand(
  conversation: Conversation,
  message: string
): Promise<CommandResult> {
  const { command, args } = parseCommand(message);

  switch (command) {
    case 'quickref':
    case 'agents': {
      // Single file documentation commands
      const docMap: Record<string, string> = {
        quickref: 'AGENT_QUICKREF.md',
        agents: 'AGENT_CATALOGUE.md',
      };
      const docFile = docMap[command] || 'AGENT_QUICKREF.md';
      const homePath = process.env.HOME || '/home/appuser';
      const docPath = join(homePath, '.claude', docFile);

      try {
        const content = await readFile(docPath, 'utf-8');
        return { success: true, message: content };
      } catch {
        return {
          success: false,
          message: `Documentation not found: ${docFile}\nRun setup to copy configs from your local machine.`,
        };
      }
    }

    case 'chains': {
      // List available chains (YAML files)
      const homePath = process.env.HOME || '/home/appuser';
      const chainsDir = join(homePath, '.claude', 'chains');

      try {
        const files = await readdir(chainsDir);
        const chains = files.filter(f => f.endsWith('.yaml')).map(f => f.replace('.yaml', ''));

        if (chains.length === 0) {
          return { success: true, message: 'No chains found in ~/.claude/chains/' };
        }

        let msg = '‚õìÔ∏è **Available Chains**\n\n';
        msg += '| Chain | Description |\n|-------|-------------|\n';
        for (const chain of chains.sort()) {
          msg += `| \`${chain}\` | Multi-agent workflow |\n`;
        }
        msg += '\nUse: Tell Claude to "run the <chain> chain"';
        return { success: true, message: msg };
      } catch {
        return { success: false, message: 'Chains directory not found. Run setup first.' };
      }
    }

    case 'prompts': {
      // List available prompts (MD files)
      const homePath = process.env.HOME || '/home/appuser';
      const promptsDir = join(homePath, '.claude', 'prompts');

      try {
        const files = await readdir(promptsDir);
        const prompts = files.filter(f => f.endsWith('.md')).map(f => f.replace('.md', ''));

        if (prompts.length === 0) {
          return { success: true, message: 'No prompts found in ~/.claude/prompts/' };
        }

        let msg = 'üìù **Available Prompts**\n\n';
        for (const prompt of prompts.sort()) {
          msg += `‚Ä¢ \`${prompt}\`\n`;
        }
        msg += '\nUse: Tell Claude to "use the <prompt> prompt"';
        return { success: true, message: msg };
      } catch {
        return { success: false, message: 'Prompts directory not found. Run setup first.' };
      }
    }

    case 'commands-all': {
      // Complete command reference - all commands in one place
      const homePath = process.env.HOME || '/home/appuser';

      let msg = `üìö **AgentCommander - Complete Command Reference**

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

## üîß CODEBASE COMMANDS

\`/clone <repo-url>\` - Clone repository
\`/repos\` - List repositories (numbered)
\`/repo <#|name> [pull]\` - Switch repo (auto-loads commands)
\`/repo-remove <#|name>\` - Remove repo and codebase record
\`/getcwd\` - Show working directory
\`/setcwd <path>\` - Set directory
\`/status\` - Show current state
\`/reset\` - Clear session
\`/reset-context\` - Reset AI context, keep worktree

## üå≥ WORKTREES

\`/worktree create <branch>\` - Create isolated worktree
\`/worktree list\` - Show worktrees for this repo
\`/worktree remove [--force]\` - Remove current worktree
\`/worktree cleanup merged|stale\` - Clean up worktrees
\`/worktree orphans\` - Show all worktrees from git

## üìù COMMAND TEMPLATES

\`/<name> [args]\` - Invoke a template directly
\`/templates\` - List all templates
\`/template-add <name> <path>\` - Add template from file
\`/template-delete <name>\` - Remove a template

## üìÅ CODEBASE COMMANDS (per-project)

\`/command-set <name> <path> [text]\` - Register command
\`/load-commands <folder>\` - Bulk load (recursive)
\`/command-invoke <name> [args]\` - Execute
\`/commands\` - List registered
\`/init\` - Create .lugh structure

## ü§ñ AGENT ARMY REFERENCE

\`/quickref\` - Agent cheatsheet (chains, prompts, utilities)
\`/agents\` - Full 59-agent catalogue
\`/chains\` - Multi-agent workflows
\`/prompts\` - Reusable prompt templates

## üìã HELP

\`/help\` - Quick command reference
\`/commands-all\` - This complete reference

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

`;

      // Add dynamic data: chains and prompts
      try {
        const chainsDir = join(homePath, '.claude', 'chains');
        const chainFiles = await readdir(chainsDir);
        const chains = chainFiles.filter(f => f.endsWith('.yaml')).map(f => f.replace('.yaml', ''));
        if (chains.length > 0) {
          msg += `## ‚õìÔ∏è AVAILABLE CHAINS (${String(chains.length)})\n\n`;
          for (const chain of chains.sort()) {
            msg += `‚Ä¢ \`${chain}\`\n`;
          }
          msg += '\n';
        }
      } catch {
        // No chains directory
      }

      try {
        const promptsDir = join(homePath, '.claude', 'prompts');
        const promptFiles = await readdir(promptsDir);
        const prompts = promptFiles.filter(f => f.endsWith('.md')).map(f => f.replace('.md', ''));
        if (prompts.length > 0) {
          msg += `## üìù AVAILABLE PROMPTS (${String(prompts.length)})\n\n`;
          for (const prompt of prompts.sort()) {
            msg += `‚Ä¢ \`${prompt}\`\n`;
          }
          msg += '\n';
        }
      } catch {
        // No prompts directory
      }

      // Add database templates if any
      const dbTemplates = await templateDb.getAllTemplates();
      if (dbTemplates.length > 0) {
        msg += `## üóÉÔ∏è DATABASE TEMPLATES (${String(dbTemplates.length)})\n\n`;
        for (const t of dbTemplates) {
          msg += `‚Ä¢ \`/${t.name}\``;
          if (t.description) {
            msg += ` - ${t.description}`;
          }
          msg += '\n';
        }
        msg += '\n';
      }

      // Add codebase commands if available
      if (conversation.codebase_id) {
        const codebase = await codebaseDb.getCodebase(conversation.codebase_id);
        const commands = codebase?.commands ?? {};
        const cmdCount = Object.keys(commands).length;
        if (cmdCount > 0) {
          msg += `## üì¶ CODEBASE COMMANDS (${String(cmdCount)})\n\n`;
          for (const [name, def] of Object.entries(commands)) {
            msg += `‚Ä¢ \`/${name}\` - ${def.path}\n`;
          }
          msg += '\n';
        }
      }

      msg += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
*AgentCommander ‚Äî Streets Digital Ltd*`;

      return { success: true, message: msg };
    }

    case 'help':
      return {
        success: true,
        message: `Available Commands:

Command Templates (global):
  /<name> [args] - Invoke a template directly
  /templates - List all templates
  /template-add <name> <path> - Add template from file
  /template-delete <name> - Remove a template

Codebase Commands (per-project):
  /command-set <name> <path> [text] - Register command
  /load-commands <folder> - Bulk load (recursive)
  /command-invoke <name> [args] - Execute
  /commands - List registered
  Note: Commands use relative paths (e.g., .lugh/commands)

Codebase:
  /clone <repo-url> - Clone repository
  /repos - List repositories (numbered)
  /repo <#|name> [pull] - Switch repo (auto-loads commands)
  /repo-remove <#|name> - Remove repo and codebase record
  /getcwd - Show working directory
  /setcwd <path> - Set directory
  Note: Use /repo for quick switching, /setcwd for manual paths

Worktrees:
  /worktree create <branch> - Create isolated worktree
  /worktree list - Show worktrees for this repo
  /worktree remove [--force] - Remove current worktree
  /worktree cleanup merged|stale - Clean up worktrees
  /worktree orphans - Show all worktrees from git

Session:
  /status - Show state
  /reset - Clear session
  /reset-context - Reset AI context, keep worktree
  /stop - Emergency abort (stops current operation)
  /help - Show help

Reference:
  /quickref - Agent army cheatsheet
  /agents - Full agent catalogue
  /chains - Multi-agent workflows
  /prompts - Reusable prompts

Setup:
  /init - Create .lugh structure in current repo
  /verbose [on|off] - Toggle verbose logging`,
      };

    case 'verbose': {
      // Toggle or set verbose logging
      if (args.length === 0) {
        // Toggle
        const newState = toggleVerbose();
        return {
          success: true,
          message: `Verbose logging ${newState ? '**ENABLED** ‚úÖ' : '**DISABLED** ‚ùå'}\n\nView logs with:\n\`docker-compose --profile with-db logs -f app-with-db\``,
        };
      } else if (args[0] === 'on') {
        setVerbose(true);
        return {
          success: true,
          message: `Verbose logging **ENABLED** ‚úÖ\n\nView logs with:\n\`docker-compose --profile with-db logs -f app-with-db\``,
        };
      } else if (args[0] === 'off') {
        setVerbose(false);
        return {
          success: true,
          message: `Verbose logging **DISABLED** ‚ùå`,
        };
      } else if (args[0] === 'status') {
        const status = isVerboseEnabled();
        return {
          success: true,
          message: `Verbose logging is currently ${status ? '**ENABLED** ‚úÖ' : '**DISABLED** ‚ùå'}`,
        };
      } else {
        return {
          success: false,
          message: `Usage: /verbose [on|off|status]\n\nWithout arguments, toggles verbose logging.`,
        };
      }
    }

    case 'status': {
      let msg = `Platform: ${conversation.platform_type}\nAI Assistant: ${conversation.ai_assistant_type}`;

      let codebase = conversation.codebase_id
        ? await codebaseDb.getCodebase(conversation.codebase_id)
        : null;

      // Auto-detect codebase from cwd if not explicitly linked
      if (!codebase && conversation.cwd) {
        codebase = await codebaseDb.findCodebaseByDefaultCwd(conversation.cwd);
        if (codebase) {
          // Auto-link the detected codebase to this conversation
          await db.updateConversation(conversation.id, { codebase_id: codebase.id });
          console.log(`[Status] Auto-linked codebase ${codebase.name} to conversation`);
        }
      }

      if (codebase?.name) {
        msg += `\n\nCodebase: ${codebase.name}`;
        if (codebase.repository_url) {
          msg += `\nRepository: ${codebase.repository_url}`;
        }
      } else {
        msg += '\n\nNo codebase configured. Use /clone <repo-url> to get started.';
      }

      msg += `\n\nCurrent Working Directory: ${conversation.cwd ?? 'Not set'}`;

      const activeIsolation = conversation.isolation_env_id;
      if (activeIsolation) {
        const repoRoot = codebase?.default_cwd;
        const shortPath = shortenPath(activeIsolation, repoRoot);
        msg += `\nWorktree: ${shortPath}`;
      }

      const session = await sessionDb.getActiveSession(conversation.id);
      if (session?.id) {
        msg += `\nActive Session: ${session.id.slice(0, 8)}...`;
      }

      // Add worktree breakdown if codebase is configured (Phase 3D)
      if (codebase) {
        try {
          const breakdown = await getWorktreeStatusBreakdown(codebase.id, codebase.default_cwd);
          msg += `\n\nWorktrees: ${String(breakdown.total)}/${String(breakdown.limit)}`;
          if (breakdown.merged > 0 || breakdown.stale > 0) {
            if (breakdown.merged > 0) {
              msg += `\n  ‚Ä¢ ${String(breakdown.merged)} merged (can auto-remove)`;
            }
            if (breakdown.stale > 0) {
              msg += `\n  ‚Ä¢ ${String(breakdown.stale)} stale (14+ days inactive)`;
            }
            msg += `\n  ‚Ä¢ ${String(breakdown.active)} active`;
          }
        } catch (error) {
          // Don't fail status if breakdown fails
          console.error('[Status] Failed to get worktree breakdown:', error);
        }
      }

      return { success: true, message: msg };
    }

    case 'getcwd':
      return {
        success: true,
        message: `Current working directory: ${conversation.cwd ?? 'Not set'}`,
      };

    case 'setcwd': {
      if (args.length === 0) {
        return { success: false, message: 'Usage: /setcwd <path>' };
      }
      const newCwd = args.join(' ');
      const resolvedCwd = resolve(newCwd);

      // Validate path is within workspace to prevent path traversal
      const workspacePath = getLughWorkspacesPath();
      if (!isPathWithinWorkspace(resolvedCwd)) {
        return { success: false, message: `Path must be within ${workspacePath} directory` };
      }

      await db.updateConversation(conversation.id, { cwd: resolvedCwd });

      // Add this directory to git safe.directory if it's a git repository
      // This prevents "dubious ownership" errors when working with existing repos
      // Use execFile instead of execAsync to prevent command injection
      try {
        await execFileAsync('git', ['config', '--global', '--add', 'safe.directory', resolvedCwd]);
        console.log(`[Command] Added ${resolvedCwd} to git safe.directory`);
      } catch (_error) {
        // Ignore errors - directory might not be a git repo
        console.log(
          `[Command] Could not add ${resolvedCwd} to safe.directory (might not be a git repo)`
        );
      }

      // Reset session when changing working directory
      const session = await sessionDb.getActiveSession(conversation.id);
      if (session) {
        await sessionDb.deactivateSession(session.id);
        console.log('[Command] Deactivated session after cwd change');
      }

      return {
        success: true,
        message: `Working directory set to: ${resolvedCwd}\n\nSession reset - starting fresh on next message.`,
        modified: true,
      };
    }

    case 'clone': {
      if (args.length === 0 || !args[0]) {
        return { success: false, message: 'Usage: /clone <repo-url>' };
      }

      // Normalize URL: strip trailing slashes
      const normalizedUrl: string = args[0].replace(/\/+$/, '');

      // Convert SSH URL to HTTPS format if needed
      // git@github.com:user/repo.git -> https://github.com/user/repo.git
      let workingUrl = normalizedUrl;
      if (normalizedUrl.startsWith('git@github.com:')) {
        workingUrl = normalizedUrl.replace('git@github.com:', 'https://github.com/');
      }

      // Extract owner and repo from URL
      // https://github.com/owner/repo.git -> owner, repo
      const urlParts = workingUrl.replace(/\.git$/, '').split('/');
      const repoName = urlParts.pop() ?? 'unknown';
      const ownerName = urlParts.pop() ?? 'unknown';

      // Use Lugh workspaces path (LUGH_HOME/workspaces or ~/.lugh/workspaces)
      // Include owner in path to prevent collisions (e.g., alice/utils vs bob/utils)
      const workspacePath = getLughWorkspacesPath();
      const targetPath = join(workspacePath, ownerName, repoName);

      try {
        // Check if target directory already exists
        try {
          await access(targetPath);

          // Directory exists - try to find existing codebase by repo URL
          // Check both with and without .git suffix (per github.ts pattern)
          const urlNoGit = workingUrl.replace(/\.git$/, '');
          const urlWithGit = urlNoGit + '.git';

          const existingCodebase =
            (await codebaseDb.findCodebaseByRepoUrl(urlNoGit)) ??
            (await codebaseDb.findCodebaseByRepoUrl(urlWithGit));

          if (existingCodebase) {
            // Link conversation to existing codebase
            await db.updateConversation(conversation.id, {
              codebase_id: existingCodebase.id,
              cwd: targetPath,
            });

            // Reset session when switching codebases
            const session = await sessionDb.getActiveSession(conversation.id);
            if (session) {
              await sessionDb.deactivateSession(session.id);
            }

            // Check for command folders (same logic as successful clone)
            let commandFolder: string | null = null;
            for (const folder of getCommandFolderSearchPaths()) {
              try {
                await access(join(targetPath, folder));
                commandFolder = folder;
                break;
              } catch {
                /* ignore */
              }
            }

            let responseMessage = `Repository already cloned.\n\nLinked to existing codebase: ${existingCodebase.name}\nPath: ${targetPath}\n\nSession reset - starting fresh on next message.`;

            if (commandFolder) {
              responseMessage += `\n\nüìÅ Found: ${commandFolder}/\nUse /load-commands ${commandFolder} to register commands.`;
            }

            return {
              success: true,
              message: responseMessage,
              modified: true,
            };
          }

          // Directory exists but no codebase found
          return {
            success: false,
            message: `Directory already exists: ${targetPath}\n\nNo matching codebase found in database. Options:\n- Remove the directory and re-clone\n- Use /setcwd ${targetPath} (limited functionality)`,
          };
        } catch {
          // Directory doesn't exist, proceed with clone
        }

        console.log(`[Clone] Cloning ${workingUrl} to ${targetPath}`);

        // Build clone command with authentication if GitHub token is available
        let cloneUrl = workingUrl;
        const ghToken = process.env.GH_TOKEN;

        if (ghToken && workingUrl.includes('github.com')) {
          // Inject token into GitHub URL for private repo access
          // Convert: https://github.com/user/repo.git -> https://token@github.com/user/repo.git
          if (workingUrl.startsWith('https://github.com')) {
            cloneUrl = workingUrl.replace('https://github.com', `https://${ghToken}@github.com`);
          } else if (workingUrl.startsWith('http://github.com')) {
            cloneUrl = workingUrl.replace('http://github.com', `https://${ghToken}@github.com`);
          } else if (!workingUrl.startsWith('http')) {
            // Handle github.com/user/repo format (bare domain)
            cloneUrl = `https://${ghToken}@${workingUrl}`;
          }
          console.log('[Clone] Using authenticated GitHub clone');
        }

        await execFileAsync('git', ['clone', cloneUrl, targetPath]);

        // Add the cloned repository to git safe.directory to prevent ownership errors
        // This is needed because we run as non-root user but git might see different ownership
        await execFileAsync('git', ['config', '--global', '--add', 'safe.directory', targetPath]);
        console.log(`[Clone] Added ${targetPath} to git safe.directory`);

        // Auto-detect assistant type based on folder structure
        let suggestedAssistant = 'claude';
        const codexFolder = join(targetPath, '.codex');
        const claudeFolder = join(targetPath, '.claude');

        try {
          await access(codexFolder);
          suggestedAssistant = 'codex';
          console.log('[Clone] Detected .codex folder - using Codex assistant');
        } catch {
          try {
            await access(claudeFolder);
            suggestedAssistant = 'claude';
            console.log('[Clone] Detected .claude folder - using Claude assistant');
          } catch {
            // Default to claude
            console.log('[Clone] No assistant folder detected - defaulting to Claude');
          }
        }

        const codebase = await codebaseDb.createCodebase({
          name: `${ownerName}/${repoName}`,
          repository_url: workingUrl,
          default_cwd: targetPath,
          ai_assistant_type: suggestedAssistant,
        });

        await db.updateConversation(conversation.id, {
          codebase_id: codebase.id,
          cwd: targetPath,
        });

        // Reset session when cloning a new repository
        const session = await sessionDb.getActiveSession(conversation.id);
        if (session) {
          await sessionDb.deactivateSession(session.id);
          console.log('[Command] Deactivated session after clone');
        }

        // Auto-load commands if found
        let commandsLoaded = 0;
        for (const folder of getCommandFolderSearchPaths()) {
          try {
            const commandPath = join(targetPath, folder);
            await access(commandPath);

            const markdownFiles = await findMarkdownFilesRecursive(commandPath);
            if (markdownFiles.length > 0) {
              const commands = await codebaseDb.getCodebaseCommands(codebase.id);
              markdownFiles.forEach(({ commandName, relativePath }) => {
                commands[commandName] = {
                  path: join(folder, relativePath),
                  description: `From ${folder}`,
                };
              });
              await codebaseDb.updateCodebaseCommands(codebase.id, commands);
              commandsLoaded = markdownFiles.length;
              break;
            }
          } catch {
            // Folder doesn't exist, try next
          }
        }

        let responseMessage = `Repository cloned successfully!\n\nCodebase: ${repoName}\nPath: ${targetPath}`;
        if (commandsLoaded > 0) {
          responseMessage += `\n‚úì Loaded ${String(commandsLoaded)} commands`;
        }
        responseMessage +=
          '\n\nSession reset - starting fresh on next message.\n\nYou can now start asking questions about the code.';

        return {
          success: true,
          message: responseMessage,
          modified: true,
        };
      } catch (error) {
        const err = error as Error;
        console.error('[Clone] Failed:', err);
        return {
          success: false,
          message: `Failed to clone repository: ${err.message}`,
        };
      }
    }

    case 'command-set': {
      if (args.length < 2) {
        return { success: false, message: 'Usage: /command-set <name> <path> [text]' };
      }
      if (!conversation.codebase_id) {
        return { success: false, message: 'No codebase configured. Use /clone first.' };
      }

      const [commandName, commandPath, ...textParts] = args;
      const commandText = textParts.join(' ');
      const workspacePath = getLughWorkspacesPath();
      const basePath = conversation.cwd ?? workspacePath;
      const fullPath = resolve(basePath, commandPath);

      // Validate path is within workspace to prevent path traversal
      if (!isPathWithinWorkspace(fullPath)) {
        return { success: false, message: `Path must be within ${workspacePath} directory` };
      }

      try {
        if (commandText) {
          await writeFile(fullPath, commandText, 'utf-8');
        } else {
          await readFile(fullPath, 'utf-8'); // Validate exists
        }
        await codebaseDb.registerCommand(conversation.codebase_id, commandName, {
          path: commandPath,
          description: `Custom: ${commandName}`,
        });
        return {
          success: true,
          message: `Command '${commandName}' registered!\nPath: ${commandPath}`,
        };
      } catch (error) {
        const err = error as Error;
        console.error('[Command] command-set failed:', err);
        return { success: false, message: `Failed: ${err.message}` };
      }
    }

    case 'load-commands': {
      if (!args.length) {
        return { success: false, message: 'Usage: /load-commands <folder>' };
      }
      if (!conversation.codebase_id) {
        return { success: false, message: 'No codebase configured.' };
      }

      const folderPath = args.join(' ');
      const workspacePath = getLughWorkspacesPath();
      const basePath = conversation.cwd ?? workspacePath;
      const fullPath = resolve(basePath, folderPath);

      // Validate path is within workspace to prevent path traversal
      if (!isPathWithinWorkspace(fullPath)) {
        return { success: false, message: `Path must be within ${workspacePath} directory` };
      }

      try {
        // Recursively find all .md files
        const markdownFiles = await findMarkdownFilesRecursive(fullPath);

        if (!markdownFiles.length) {
          return {
            success: false,
            message: `No .md files found in ${folderPath} (searched recursively)`,
          };
        }

        const commands = await codebaseDb.getCodebaseCommands(conversation.codebase_id);

        // Register each command (later files with same name will override earlier ones)
        markdownFiles.forEach(({ commandName, relativePath }) => {
          commands[commandName] = {
            path: join(folderPath, relativePath),
            description: `From ${folderPath}`,
          };
        });

        await codebaseDb.updateCodebaseCommands(conversation.codebase_id, commands);

        return {
          success: true,
          message: `Loaded ${String(markdownFiles.length)} commands recursively: ${markdownFiles.map(f => f.commandName).join(', ')}`,
        };
      } catch (error) {
        const err = error as Error;
        console.error('[Command] load-commands failed:', err);
        return { success: false, message: `Failed: ${err.message}` };
      }
    }

    case 'commands': {
      if (!conversation.codebase_id) {
        return { success: false, message: 'No codebase configured.' };
      }

      const codebase = await codebaseDb.getCodebase(conversation.codebase_id);
      const commands = codebase?.commands ?? {};

      if (!Object.keys(commands).length) {
        return {
          success: true,
          message: 'No commands registered.\n\nUse /command-set or /load-commands.',
        };
      }

      let msg = 'Registered Commands:\n\n';
      for (const [name, def] of Object.entries(commands)) {
        msg += `${name} - ${def.path}\n`;
      }
      return { success: true, message: msg };
    }

    case 'repos': {
      const workspacePath = getLughWorkspacesPath();

      try {
        const entries = await readdir(workspacePath, { withFileTypes: true });
        const folders = entries
          .filter(entry => entry.isDirectory())
          .map(entry => entry.name)
          .sort();

        if (!folders.length) {
          return {
            success: true,
            message: 'No repositories found in /workspace\n\nUse /clone <repo-url> to add one.',
          };
        }

        // Get current codebase to check for active repo (consistent with /status)
        let currentCodebase = conversation.codebase_id
          ? await codebaseDb.getCodebase(conversation.codebase_id)
          : null;

        // Auto-detect codebase from cwd if not explicitly linked (same as /status)
        if (!currentCodebase && conversation.cwd) {
          currentCodebase = await codebaseDb.findCodebaseByDefaultCwd(conversation.cwd);
        }

        let msg = 'Repositories:\n\n';

        for (let i = 0; i < folders.length; i++) {
          const folder = folders[i];
          const folderPath = join(workspacePath, folder);
          // Mark as active only if current codebase's default_cwd matches this folder
          const isActive = currentCodebase?.default_cwd === folderPath;
          const marker = isActive ? ' ‚Üê active' : '';
          msg += `${String(i + 1)}. ${folder}${marker}\n`;
        }

        msg += '\nUse /repo <number|name> to switch';

        return { success: true, message: msg };
      } catch (error) {
        const err = error as Error;
        console.error('[Command] repos failed:', err);
        return { success: false, message: `Failed to list repositories: ${err.message}` };
      }
    }

    case 'reset': {
      const session = await sessionDb.getActiveSession(conversation.id);
      if (session) {
        await sessionDb.deactivateSession(session.id);
        return {
          success: true,
          message:
            'Session cleared. Starting fresh on next message.\n\nCodebase configuration preserved.',
        };
      }
      return {
        success: true,
        message: 'No active session to reset.',
      };
    }

    case 'reset-context': {
      // Reset AI session while keeping worktree
      const activeSession = await sessionDb.getActiveSession(conversation.id);
      if (activeSession) {
        await sessionDb.deactivateSession(activeSession.id);
        return {
          success: true,
          message:
            'AI context reset. Your next message will start a fresh conversation while keeping your current working directory.',
        };
      }
      return {
        success: true,
        message: 'No active session to reset.',
      };
    }

    case 'stop': {
      // Emergency stop - abort the current operation but keep session alive for follow-up
      // Claude will ask why the user stopped and what they'd like to do differently

      // Signal abort to interrupt any running AI query
      const aborted = signalAbort(conversation.platform_conversation_id);
      console.log(
        `[CommandHandler] /stop: signalAbort(${conversation.platform_conversation_id}) = ${aborted}`
      );

      const activeSession = await sessionDb.getActiveSession(conversation.id);

      // Keep session alive so Claude can ask follow-up questions
      // Only deactivate if there's no session at all
      if (activeSession) {
        return {
          success: true,
          message: aborted
            ? 'üõë **STOPPED** - Operation interrupted.'
            : 'üõë **STOPPED** - Stopping after current action completes.',
          // This prompt will be sent to Claude to ask clarifying questions
          followUpPrompt: `The user just sent /stop to interrupt the previous operation.

Please respond conversationally:
1. Acknowledge that you've stopped
2. Briefly mention what you were doing (if you remember)
3. Ask the user what went wrong or what they'd like you to do differently
4. Offer 2-3 specific options for how to proceed (e.g., "try a different approach", "explain what I was doing", "start over with new instructions")

Keep your response concise and helpful. The user stopped you for a reason - find out why and help them.`,
        };
      }

      return {
        success: true,
        message: 'üõë No active operation to stop.',
      };
    }

    case 'repo': {
      if (args.length === 0) {
        return { success: false, message: 'Usage: /repo <number|name> [pull]' };
      }

      const workspacePath = getLughWorkspacesPath();
      const identifier = args[0];
      const shouldPull = args[1]?.toLowerCase() === 'pull';

      try {
        // Get sorted list of repos (same as /repos)
        const entries = await readdir(workspacePath, { withFileTypes: true });
        const folders = entries
          .filter(entry => entry.isDirectory())
          .map(entry => entry.name)
          .sort();

        if (!folders.length) {
          return {
            success: false,
            message: 'No repositories found. Use /clone <repo-url> first.',
          };
        }

        // Find the target folder by number or name
        let targetFolder: string | undefined;
        const num = parseInt(identifier, 10);
        if (!isNaN(num) && num >= 1 && num <= folders.length) {
          targetFolder = folders[num - 1];
        } else {
          // Try exact match first, then prefix match
          targetFolder =
            folders.find(f => f === identifier) ?? folders.find(f => f.startsWith(identifier));
        }

        if (!targetFolder) {
          return {
            success: false,
            message: `Repository not found: ${identifier}\n\nUse /repos to see available repositories.`,
          };
        }

        const targetPath = join(workspacePath, targetFolder);

        // Git pull if requested
        if (shouldPull) {
          try {
            await execFileAsync('git', ['-C', targetPath, 'pull']);
            console.log(`[Command] Pulled latest for ${targetFolder}`);
          } catch (pullError) {
            const err = pullError as Error;
            console.error('[Command] git pull failed:', err);
            return {
              success: false,
              message: `Failed to pull: ${err.message}`,
            };
          }
        }

        // Find or create codebase for this path
        let codebase = await codebaseDb.findCodebaseByDefaultCwd(targetPath);

        if (!codebase) {
          // Create new codebase for this directory
          // Auto-detect assistant type
          let suggestedAssistant = 'claude';
          try {
            await access(join(targetPath, '.codex'));
            suggestedAssistant = 'codex';
          } catch {
            // Default to claude
          }

          codebase = await codebaseDb.createCodebase({
            name: targetFolder,
            default_cwd: targetPath,
            ai_assistant_type: suggestedAssistant,
          });
          console.log(`[Command] Created codebase for ${targetFolder}`);
        }

        // Link conversation to codebase
        await db.updateConversation(conversation.id, {
          codebase_id: codebase.id,
          cwd: targetPath,
        });

        // Reset session when switching
        const session = await sessionDb.getActiveSession(conversation.id);
        if (session) {
          await sessionDb.deactivateSession(session.id);
        }

        // Auto-load commands if found
        let commandsLoaded = 0;
        for (const folder of getCommandFolderSearchPaths()) {
          try {
            const commandPath = join(targetPath, folder);
            await access(commandPath);

            const markdownFiles = await findMarkdownFilesRecursive(commandPath);
            if (markdownFiles.length > 0) {
              const commands = await codebaseDb.getCodebaseCommands(codebase.id);
              markdownFiles.forEach(({ commandName, relativePath }) => {
                commands[commandName] = {
                  path: join(folder, relativePath),
                  description: `From ${folder}`,
                };
              });
              await codebaseDb.updateCodebaseCommands(codebase.id, commands);
              commandsLoaded = markdownFiles.length;
              break;
            }
          } catch {
            // Folder doesn't exist, try next
          }
        }

        let msg = `Switched to: ${targetFolder}`;
        if (shouldPull) {
          msg += '\n‚úì Pulled latest changes';
        }
        if (commandsLoaded > 0) {
          msg += `\n‚úì Loaded ${String(commandsLoaded)} commands`;
        }
        msg += '\n\nReady to work!';

        return { success: true, message: msg, modified: true };
      } catch (error) {
        const err = error as Error;
        console.error('[Command] repo switch failed:', err);
        return { success: false, message: `Failed: ${err.message}` };
      }
    }

    case 'repo-remove': {
      if (args.length === 0) {
        return { success: false, message: 'Usage: /repo-remove <number|name>' };
      }

      const workspacePath = getLughWorkspacesPath();
      const identifier = args[0];

      try {
        // Get sorted list of repos (same as /repos)
        const entries = await readdir(workspacePath, { withFileTypes: true });
        const folders = entries
          .filter(entry => entry.isDirectory())
          .map(entry => entry.name)
          .sort();

        if (!folders.length) {
          return {
            success: false,
            message: 'No repositories found. Nothing to remove.',
          };
        }

        // Find the target folder by number or name
        let targetFolder: string | undefined;
        const num = parseInt(identifier, 10);
        if (!isNaN(num) && num >= 1 && num <= folders.length) {
          targetFolder = folders[num - 1];
        } else {
          // Try exact match first, then prefix match
          targetFolder =
            folders.find(f => f === identifier) ?? folders.find(f => f.startsWith(identifier));
        }

        if (!targetFolder) {
          return {
            success: false,
            message: `Repository not found: ${identifier}\n\nUse /repos to see available repositories.`,
          };
        }

        const targetPath = join(workspacePath, targetFolder);

        // Find codebase by path
        const codebase = await codebaseDb.findCodebaseByDefaultCwd(targetPath);

        // If current conversation uses this codebase, unlink it
        if (codebase && conversation.codebase_id === codebase.id) {
          await db.updateConversation(conversation.id, { codebase_id: null, cwd: null });
          // Also deactivate any active session
          const session = await sessionDb.getActiveSession(conversation.id);
          if (session) {
            await sessionDb.deactivateSession(session.id);
          }
        }

        // Delete codebase record (this also unlinks sessions)
        if (codebase) {
          await codebaseDb.deleteCodebase(codebase.id);
          console.log(`[Command] Deleted codebase: ${codebase.name}`);
        }

        // Remove directory
        await rm(targetPath, { recursive: true, force: true });
        console.log(`[Command] Removed directory: ${targetPath}`);

        let msg = `Removed: ${targetFolder}`;
        if (codebase) {
          msg += '\n‚úì Deleted codebase record';
        }
        if (conversation.codebase_id === codebase?.id) {
          msg += '\n‚úì Unlinked from current conversation';
        }

        return { success: true, message: msg, modified: true };
      } catch (error) {
        const err = error as Error;
        console.error('[Command] repo-remove failed:', err);
        return { success: false, message: `Failed to remove: ${err.message}` };
      }
    }

    case 'template-add': {
      if (args.length < 2) {
        return { success: false, message: 'Usage: /template-add <name> <file-path>' };
      }
      if (!conversation.cwd) {
        return {
          success: false,
          message: 'No working directory set. Use /clone or /setcwd first.',
        };
      }

      const [templateName, ...pathParts] = args;
      const filePath = pathParts.join(' ');
      const fullPath = resolve(conversation.cwd, filePath);

      try {
        const content = await readFile(fullPath, 'utf-8');

        // Extract description from frontmatter if present
        const frontmatterMatch = /^---\n([\s\S]*?)\n---/.exec(content);
        let description: string | undefined;
        if (frontmatterMatch) {
          const descMatch = /description:\s*(.+)/.exec(frontmatterMatch[1]);
          description = descMatch?.[1]?.trim();
        }

        await templateDb.upsertTemplate({
          name: templateName,
          description: description ?? `From ${filePath}`,
          content,
        });

        return {
          success: true,
          message: `Template '${templateName}' saved!\n\nUse it with: /${templateName} [args]`,
        };
      } catch (error) {
        const err = error as Error;
        return { success: false, message: `Failed to read file: ${err.message}` };
      }
    }

    case 'template-list':
    case 'templates': {
      const templates = await templateDb.getAllTemplates();

      if (templates.length === 0) {
        return {
          success: true,
          message:
            'No command templates registered.\n\nUse /template-add <name> <file-path> to add one.',
        };
      }

      let msg = 'Command Templates:\n\n';
      for (const t of templates) {
        msg += `/${t.name}`;
        if (t.description) {
          msg += ` - ${t.description}`;
        }
        msg += '\n';
      }
      msg += '\nUse /<name> [args] to invoke any template.';
      return { success: true, message: msg };
    }

    case 'template-delete': {
      if (args.length < 1) {
        return { success: false, message: 'Usage: /template-delete <name>' };
      }

      const deleted = await templateDb.deleteTemplate(args[0]);
      if (deleted) {
        return { success: true, message: `Template '${args[0]}' deleted.` };
      }
      return { success: false, message: `Template '${args[0]}' not found.` };
    }

    case 'worktree': {
      const subcommand = args[0];

      if (!conversation.codebase_id) {
        return { success: false, message: 'No codebase configured. Use /clone first.' };
      }

      const codebase = await codebaseDb.getCodebase(conversation.codebase_id);
      if (!codebase) {
        return { success: false, message: 'Codebase not found.' };
      }

      const mainPath = codebase.default_cwd;

      switch (subcommand) {
        case 'create': {
          const branchName = args[1];
          if (!branchName) {
            return { success: false, message: 'Usage: /worktree create <branch-name>' };
          }

          // Check if already using a worktree
          const existingIsolation = conversation.isolation_env_id;
          if (existingIsolation) {
            const shortPath = shortenPath(existingIsolation, mainPath);
            return {
              success: false,
              message: `Already using worktree: ${shortPath}\n\nRun /worktree remove first.`,
            };
          }

          // Validate branch name (alphanumeric, dash, underscore only)
          if (!/^[a-zA-Z0-9_-]+$/.test(branchName)) {
            return {
              success: false,
              message: 'Branch name must contain only letters, numbers, dashes, and underscores.',
            };
          }

          try {
            // Use isolation provider for worktree creation
            const provider = getIsolationProvider();
            const env = await provider.create({
              codebaseId: conversation.codebase_id,
              canonicalRepoPath: mainPath,
              workflowType: 'task',
              identifier: branchName,
              description: `Manual worktree: ${branchName}`,
            });

            // Add to git safe.directory
            await execFileAsync('git', [
              'config',
              '--global',
              '--add',
              'safe.directory',
              env.workingPath,
            ]);

            // Update conversation with isolation info
            await db.updateConversation(conversation.id, {
              isolation_env_id: env.id,
              cwd: env.workingPath,
            });

            // NOTE: Do NOT deactivate session - preserve AI context per plan

            const shortPath = shortenPath(env.workingPath, mainPath);
            return {
              success: true,
              message: `Worktree created!\n\nBranch: ${env.branchName ?? branchName}\nPath: ${shortPath}\n\nThis conversation now works in isolation.\nRun dependency install if needed (e.g., bun install).`,
              modified: true,
            };
          } catch (error) {
            const err = error as Error;
            console.error('[Worktree] Create failed:', err);

            // Check for common errors
            if (err.message.includes('already exists')) {
              return {
                success: false,
                message: `Branch '${branchName}' already exists. Use a different name.`,
              };
            }
            return { success: false, message: `Failed to create worktree: ${err.message}` };
          }
        }

        case 'list': {
          try {
            const { stdout } = await execFileAsync('git', ['-C', mainPath, 'worktree', 'list']);

            // Parse output and mark current
            const lines = stdout.trim().split('\n');
            let msg = 'Worktrees:\n\n';

            const currentWorktree = conversation.isolation_env_id;

            for (const line of lines) {
              // Extract the path (first part before whitespace)
              const parts = line.split(/\s+/);
              const fullPath = parts[0];
              const shortPath = shortenPath(fullPath, mainPath);

              // Reconstruct line with shortened path
              const restOfLine = parts.slice(1).join(' ');
              const shortenedLine = restOfLine ? `${shortPath} ${restOfLine}` : shortPath;

              const isActive = currentWorktree && line.startsWith(currentWorktree);
              const marker = isActive ? ' <- active' : '';
              msg += `${shortenedLine}${marker}\n`;
            }

            return { success: true, message: msg };
          } catch (error) {
            const err = error as Error;
            return { success: false, message: `Failed to list worktrees: ${err.message}` };
          }
        }

        case 'remove': {
          const isolationEnvId = conversation.isolation_env_id;
          if (!isolationEnvId) {
            return { success: false, message: 'This conversation is not using a worktree.' };
          }

          const forceFlag = args[1] === '--force';

          try {
            // Use isolation provider for removal
            const provider = getIsolationProvider();
            await provider.destroy(isolationEnvId, { force: forceFlag });

            // Clear isolation reference, set cwd to main repo
            await db.updateConversation(conversation.id, {
              isolation_env_id: null,
              cwd: mainPath,
            });

            // Reset session
            const session = await sessionDb.getActiveSession(conversation.id);
            if (session) {
              await sessionDb.deactivateSession(session.id);
            }

            const shortPath = shortenPath(isolationEnvId, mainPath);
            return {
              success: true,
              message: `Worktree removed: ${shortPath}\n\nSwitched back to main repo.`,
              modified: true,
            };
          } catch (error) {
            const err = error as Error;
            console.error('[Worktree] Remove failed:', err);

            // Provide friendly error for uncommitted changes
            if (err.message.includes('untracked files') || err.message.includes('modified')) {
              return {
                success: false,
                message:
                  'Worktree has uncommitted changes.\n\nCommit your work first, or use `/worktree remove --force` to discard.',
              };
            }
            return { success: false, message: `Failed to remove worktree: ${err.message}` };
          }
        }

        case 'orphans': {
          // Show all worktrees from git perspective (source of truth)
          // Useful for discovering skill-created worktrees or stale entries
          const gitWorktrees = await listWorktrees(mainPath);

          if (gitWorktrees.length <= 1) {
            return {
              success: true,
              message:
                'No worktrees found (only main repo).\n\nUse `/worktree create <branch>` to create one.',
            };
          }

          const currentWorktree = conversation.isolation_env_id;

          let msg = 'All worktrees (from git):\n\n';
          for (const wt of gitWorktrees) {
            const isMainRepo = wt.path === mainPath;
            if (isMainRepo) continue;

            const shortPath = shortenPath(wt.path, mainPath);
            const isCurrent = wt.path === currentWorktree;
            const marker = isCurrent ? ' ‚Üê current' : '';
            msg += `  ${wt.branch} ‚Üí ${shortPath}${marker}\n`;
          }

          msg += '\nNote: This shows ALL worktrees including those created by external tools.\n';
          msg += 'Git (`git worktree list`) is the source of truth.';

          return { success: true, message: msg };
        }

        case 'cleanup': {
          const cleanupType = args[1];

          if (!cleanupType || !['merged', 'stale'].includes(cleanupType)) {
            return {
              success: false,
              message:
                'Usage:\n  /worktree cleanup merged - Remove worktrees with merged branches\n  /worktree cleanup stale - Remove inactive worktrees (14+ days)',
            };
          }

          try {
            let result;
            if (cleanupType === 'merged') {
              result = await cleanupMergedWorktrees(conversation.codebase_id, mainPath);
            } else {
              result = await cleanupStaleWorktrees(conversation.codebase_id, mainPath);
            }

            let msg = '';

            if (result.removed.length > 0) {
              msg += `Cleaned up ${String(result.removed.length)} ${cleanupType} worktree(s):\n`;
              for (const branch of result.removed) {
                msg += `  ‚Ä¢ ${branch}\n`;
              }
            } else {
              msg += `No ${cleanupType} worktrees to clean up.\n`;
            }

            if (result.skipped.length > 0) {
              msg += `\nSkipped ${String(result.skipped.length)} (protected):\n`;
              for (const { branchName, reason } of result.skipped) {
                msg += `  ‚Ä¢ ${branchName} (${reason})\n`;
              }
            }

            // Show updated count
            const count = await isolationEnvDb.countByCodebase(conversation.codebase_id);
            msg += `\nWorktrees: ${String(count)}/${String(MAX_WORKTREES_PER_CODEBASE)}`;

            return { success: true, message: msg.trim() };
          } catch (error) {
            const err = error as Error;
            return { success: false, message: `Failed to cleanup: ${err.message}` };
          }
        }

        default:
          return {
            success: false,
            message:
              'Usage:\n  /worktree create <branch>\n  /worktree list\n  /worktree remove [--force]\n  /worktree cleanup merged|stale\n  /worktree orphans',
          };
      }
    }

    case 'init': {
      // Create .lugh structure in current repo
      if (!conversation.cwd) {
        return {
          success: false,
          message: 'No working directory set. Use /clone or /setcwd first.',
        };
      }

      const lughDir = join(conversation.cwd, '.lugh');
      const commandsDir = join(lughDir, 'commands');
      const configPath = join(lughDir, 'config.yaml');

      try {
        // Check if .lugh already exists
        try {
          await access(lughDir);
          return {
            success: false,
            message: '.lugh directory already exists. Nothing to do.',
          };
        } catch {
          // Directory doesn't exist, we can create it
        }

        // Create directories
        await import('fs/promises').then(fs => fs.mkdir(commandsDir, { recursive: true }));

        // Create default config.yaml
        const defaultConfig = `# Lugh repository configuration
# See: https://github.com/dynamous-community/remote-coding-agent

# AI assistant preference (optional - overrides global default)
# assistant: claude

# Commands configuration (optional)
# commands:
#   folder: .lugh/commands
#   autoLoad: true
`;
        await writeFile(configPath, defaultConfig);

        // Create example command
        const exampleCommand = join(commandsDir, 'example.md');
        const exampleContent = `---
description: Example command template
---
# Example Command

This is an example command template.

Arguments:
- $1 - First positional argument
- $ARGUMENTS - All arguments as string

Task: $ARGUMENTS
`;
        await writeFile(exampleCommand, exampleContent);

        return {
          success: true,
          message: `Created .lugh structure:
  .lugh/
  ‚îú‚îÄ‚îÄ config.yaml
  ‚îî‚îÄ‚îÄ commands/
      ‚îî‚îÄ‚îÄ example.md

Use /load-commands .lugh/commands to register commands.`,
        };
      } catch (error) {
        const err = error as Error;
        console.error('[Command] init failed:', err);
        return { success: false, message: `Failed to initialize: ${err.message}` };
      }
    }

    default:
      return {
        success: false,
        message: `Unknown command: /${command}\n\nType /help to see available commands.`,
      };
  }
}
